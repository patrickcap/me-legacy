<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Buffer Overflow Protection</title>
        <!-- Rubik font, fonts.google.com -->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="styles.css">
    </head>
<body>
    <div class="container">
        <div class="brand">
            <div>PATRICK CAPALDO</div>
        </div>

        <div class="nav-wrapper">
            <div class="nav-link-wrapper">
                <a href="index.html">Home</a>
            </div>

            <div class="nav-link-wrapper">
                <a href="about.html">About</a>
            </div>

            <div class="nav-link-wrapper active-nav-link">
                <a href="tutorials.html">Tutorials</a>
            </div>

            <div class="nav-link-wrapper">
                <a href="projects.html">Projects</a>
            </div>

            <div class="nav-link-wrapper">
                <a href="https://www.linkedin.com/in/patrick-capaldo/">LinkedIn</a>
            </div>
            
            <div class="nav-link-wrapper">
                <a href="https://github.com/patrickcap">GitHub</a>
            </div>
        </div>

        <div class="sub-tutorial-main-content">
            <p>
                <i>Last updated: 16/06/2021</i>
            </p>
        </div>

        <!-- sub-tutorial content -->
        <div class="content-wrapper">
            <div class="sub-tutorial-nav-map">
                <a href="tutorials.html">Tutorials</a> > Buffer Overflow Protection
            </div>

            <div class="sub-tutorial-heading">
                <h1>Buffer Overflow Protection</h1>
            </div>
            <div class="sub-tutorial-main-content">
                Below is a list of various methods to avoid buffer overflows from occurring - more specifically using C language.<br><br>
            </div>
            <div class="sub-tutorial-sub-heading">
                Avoid Unsafe Functions<br><br>
            </div>
            <div class="sub-tutorial-main-content">
                Functions such as gets(), sprintf(), strcpy(), and strcat() are unsafe because they all encourage some 
                form of stack frame overwrite that can induce a buffer overflow. For example, strcpy() will copy a string 
                into a buffer until the null character is found - regardless of the declared size of the buffer - easily 
                inducing overflow if the user is not conscious of their buffer and input size.<br><br>
                Users should avoid these functions if possible and look for alternatives such as their corresponding 'n' 
                versions: fgets(), snprinft(), strncpy, and strncat(). These alternatives require an extra argument being
                the number of characters (or bytes) that the user wishes to be interacted with - rather than simply relying
                on the presence of a null character or not. This forces the user to know the bounds in which they are working.<br><br>
            </div>

            <div class="sub-tutorial-sub-heading">
                Bound Checking<br><br>
            </div>
            <div class="sub-tutorial-main-content">
                In addition to the practices mentioned previously, users should also be aware of the bounds of their program
                and the limitations of the functions they are using. For example, while the 'n' functions listed above require 
                more information, if the user supplies incorrect information, they will do nothing to prevent a buffer overflow 
                (e.g. giving the wrong number of characters). Due to this, it is imperative that the user is aware of how these 
                functions work and what the limitations of their buffers are to prevent an overflow. I can tell you from experience 
                that the most overlooked source of overflow is the null character. It is very often not accounted for in expected 
                buffer sizes and hence is often the cause of 1-byte overflows which are equally as dangerous as a full stack overflow.<br><br>
            </div>

            <div class="sub-tutorial-sub-heading">
                Canaries<br><br>
            </div>
            <div class="sub-tutorial-main-content">
                Just as canaries were kept in coal mines to warn for the presence of toxic gases, 
                the same method can be used in computer memory to warn for the presence of a buffer 
                overflow. The concept is quite simple - place a known value in between the buffer (what 
                can cause overflow) and the stack frame metadata (what we want to protect) (refer to 
                Figure 1).<br><br>
            </div>

            <img src="images/buffer-overflow-protection/canary.png" alt="" class="sub-tutorial-centre-image" width=10%>
            <div class="figure-comment">
                Figure 1: Canary location to identify stack buffer overflow.
            </div>  

            <div class="sub-tutorial-main-content">
                Since the value is known to the machine and not to the attacker, the machine can simply 
                check if the value has been modified after the callee function finishes and if it has, 
                the program exits safely (overflow), and if not, it continues as normal (no overflow).
                The security of this defence depends on the value of the canary chosen. If the value is 
                easy to guess or can be created naturally as a memory location - this defence is weakened.
                The value of the canary should be changed for each function call (to avoid it being 
                brute-forced) and should be difficult to guess for an attacker.
            </div>

        </div>
    </div>
</body>
</html>